// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// The service builder for [`SimpleService`].
///
/// Constructed via [`SimpleService::builder_with_plugins`] or [`SimpleService::builder_without_plugins`].
pub struct SimpleServiceBuilder<Body, L, HttpPl, ModelPl> {
    operation: Option<::aws_smithy_http_server::routing::Route<Body>>,
    layer: L,
    http_plugin: HttpPl,
    model_plugin: ModelPl,
}

impl<Body, L, HttpPl, ModelPl> SimpleServiceBuilder<Body, L, HttpPl, ModelPl> {
    /// Sets the [`Operation`](crate::operation_shape::Operation) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use simple::{Config, SimpleService};
    ///
    /// use simple::{input, output};
    ///
    /// async fn handler(input: input::OperationInput) -> output::OperationOutput {
    ///     todo!()
    /// }
    ///
    /// let config = Config::builder().build();
    /// let app = SimpleService::builder(config)
    ///     .operation(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: SimpleService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                pub fn operation<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                where
                    HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::Operation, HandlerExtractors>,

                    ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                        SimpleService<L>,
                        crate::operation_shape::Operation,
                        ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::Operation, HandlerType>
                    >,
                    ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                        SimpleService<L>,
                        crate::operation_shape::Operation,
                        ModelPl::Output
                    >,
                    HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                        SimpleService<L>,
                        crate::operation_shape::Operation,
                        <
                            ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                            as ::aws_smithy_http_server::plugin::Plugin<
                                SimpleService<L>,
                                crate::operation_shape::Operation,
                                ModelPl::Output
                            >
                        >::Output
                    >,

                    HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                    <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::Operation::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.operation_custom(svc)
    }

    /// Sets the [`Operation`](crate::operation_shape::Operation) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use simple::{Config, SimpleService};
    ///
    /// use simple::{input, output};
    ///
    /// async fn handler(input: input::OperationInput) -> Result<output::OperationOutput, std::convert::Infallible> {
    ///     todo!()
    /// }
    ///
    /// let config = Config::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = SimpleService::builder(config)
    ///     .operation_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: SimpleService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                pub fn operation_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                where
                    S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::Operation, ServiceExtractors>,

                    ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                        SimpleService<L>,
                        crate::operation_shape::Operation,
                        ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::Operation, S>
                    >,
                    ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                        SimpleService<L>,
                        crate::operation_shape::Operation,
                        ModelPl::Output
                    >,
                    HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                        SimpleService<L>,
                        crate::operation_shape::Operation,
                        <
                            ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                            as ::aws_smithy_http_server::plugin::Plugin<
                                SimpleService<L>,
                                crate::operation_shape::Operation,
                                ModelPl::Output
                            >
                        >::Output
                    >,

                    HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                    <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::Operation::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.operation_custom(svc)
    }

    /// Sets the [`Operation`](crate::operation_shape::Operation) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn operation_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.operation = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }
}

impl<Body, L, HttpPl, ModelPl> SimpleServiceBuilder<Body, L, HttpPl, ModelPl> {
    /// Constructs a [`SimpleService`] from the arguments provided to the builder.
    ///
    /// Forgetting to register a handler for one or more operations will result in an error.
    ///
    /// Check out [`SimpleServiceBuilder::build_unchecked`] if you'd prefer the service to return status code 500 when an
    /// unspecified route requested.
    pub fn build(self) -> Result<SimpleService<L::Service>, MissingOperationsError>
    where
        L: tower::Layer<
            ::aws_smithy_http_server::routing::RoutingService<
                ::aws_smithy_http_server::protocol::rest::router::RestRouter<
                    aws_smithy_http_server::routing::Route<Body>,
                >,
                ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
            >,
        >,
    {
        let router = {
            use ::aws_smithy_http_server::operation::OperationShape;
            let mut missing_operation_names = std::collections::HashMap::new();
            if self.operation.is_none() {
                missing_operation_names
                    .insert(crate::operation_shape::Operation::ID, ".operation()");
            }
            if !missing_operation_names.is_empty() {
                return Err(MissingOperationsError {
                    operation_names2setter_methods: missing_operation_names,
                });
            }
            let unexpected_error_msg = "this should never panic since we are supposed to check beforehand that a handler has been registered for this operation; please file a bug report under https://github.com/awslabs/smithy-rs/issues";

            ::aws_smithy_http_server::protocol::rest::router::RestRouter::from_iter([(
                request_specs::operation(),
                self.operation.expect(unexpected_error_msg),
            )])
        };
        let svc = self
            .layer
            .layer(::aws_smithy_http_server::routing::RoutingService::new(
                router,
            ));
        Ok(SimpleService { svc })
    }

    /// Constructs a [`SimpleService`] from the arguments provided to the builder.
    /// Operations without a handler default to returning 500 Internal Server Error to the caller.
    ///
    /// Check out [`SimpleServiceBuilder::build`] if you'd prefer the builder to fail if one or more operations do
    /// not have a registered handler.
    pub fn build_unchecked(self) -> SimpleService<L::Service>
    where
        Body: Send + 'static,
        L: tower::Layer<
            ::aws_smithy_http_server::routing::RoutingService<
                ::aws_smithy_http_server::protocol::rest::router::RestRouter<
                    aws_smithy_http_server::routing::Route<Body>,
                >,
                ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
            >,
        >,
    {
        let router = ::aws_smithy_http_server::protocol::rest::router::RestRouter::from_iter([(
            request_specs::operation(),
            self.operation.unwrap_or_else(|| {
                let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                    ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                >::default();
                ::aws_smithy_http_server::routing::Route::new(svc)
            }),
        )]);
        let svc = self
            .layer
            .layer(::aws_smithy_http_server::routing::RoutingService::new(
                router,
            ));
        SimpleService { svc }
    }
}

/// The error encountered when calling the [`SimpleServiceBuilder::build`] method if one or more operation handlers are not
/// specified.
#[derive(Debug)]
pub struct MissingOperationsError {
    operation_names2setter_methods:
        std::collections::HashMap<::aws_smithy_http_server::shape_id::ShapeId, &'static str>,
}

impl std::fmt::Display for MissingOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "You must specify a handler for all operations attached to `SimpleService`.\n\
                        We are missing handlers for the following operations:\n",
        )?;
        for operation_name in self.operation_names2setter_methods.keys() {
            writeln!(f, "- {}", operation_name.absolute())?;
        }

        writeln!(f, "\nUse the dedicated methods on `SimpleServiceBuilder` to register the missing handlers:")?;
        for setter_name in self.operation_names2setter_methods.values() {
            writeln!(f, "- {}", setter_name)?;
        }
        Ok(())
    }
}

impl std::error::Error for MissingOperationsError {}

mod request_specs {
    pub(super) fn operation() -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::POST,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("operation")),
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
}

#[allow(missing_docs)] // documentation missing in model
///
/// See the [root](crate) documentation for more information.
#[derive(Clone)]
pub struct SimpleService<S> {
    // This is the router wrapped by layers.
    svc: S,
}

impl SimpleService<()> {
    pub fn builder<
        Body,
        L,
        H: ::aws_smithy_http_server::plugin::HttpMarker,
        M: ::aws_smithy_http_server::plugin::ModelMarker,
    >(
        config: Config<L, H, M>,
    ) -> SimpleServiceBuilder<Body, L, H, M> {
        SimpleServiceBuilder {
            layer: config.layers,
            operation: None,
            http_plugin: config.http_plugins,
            model_plugin: config.model_plugins,
        }
    }
}

impl<S> SimpleService<S> {
    /// Converts [`SimpleService`] into a [`MakeService`](tower::make::MakeService).
    pub fn into_make_service(self) -> ::aws_smithy_http_server::routing::IntoMakeService<Self> {
        ::aws_smithy_http_server::routing::IntoMakeService::new(self)
    }

    /// Converts [`SimpleService`] into a [`MakeService`](tower::make::MakeService) with [`ConnectInfo`](::aws_smithy_http_server::request::connect_info::ConnectInfo).
    pub fn into_make_service_with_connect_info<C>(
        self,
    ) -> ::aws_smithy_http_server::routing::IntoMakeServiceWithConnectInfo<Self, C> {
        ::aws_smithy_http_server::routing::IntoMakeServiceWithConnectInfo::new(self)
    }
}

impl<S, R> ::tower::Service<R> for SimpleService<S>
where
    S: ::tower::Service<R>,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = S::Future;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.svc.poll_ready(cx)
    }

    fn call(&mut self, request: R) -> Self::Future {
        self.svc.call(request)
    }
}

/// An enumeration of all [operations](https://smithy.io/2.0/spec/service-types.html#operation) in SimpleService.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Operation {
    Operation,
}

impl Operation {
    /// Returns the [operations](https://smithy.io/2.0/spec/service-types.html#operation) [`ShapeId`](::aws_smithy_http_server::shape_id::ShapeId).
    pub fn shape_id(&self) -> ::aws_smithy_http_server::shape_id::ShapeId {
        match self {
            Operation::Operation => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.amazonaws.simple#Operation",
                "com.amazonaws.simple",
                "Operation",
            ),
        }
    }
}
impl<L> ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::Operation>
    for SimpleService<L>
{
    const VALUE: Operation = Operation::Operation;
}

impl<L> ::aws_smithy_http_server::service::ServiceShape for SimpleService<L> {
    const ID: ::aws_smithy_http_server::shape_id::ShapeId =
        ::aws_smithy_http_server::shape_id::ShapeId::new(
            "com.amazonaws.simple#SimpleService",
            "com.amazonaws.simple",
            "SimpleService",
        );

    const VERSION: Option<&'static str> = Some("");

    type Protocol = ::aws_smithy_http_server::protocol::rest_json_1::RestJson1;

    type Operations = Operation;
}
/// A macro to help with scoping [plugins](::aws_smithy_http_server::plugin) to a subset of all operations.
///
/// In contrast to [`aws_smithy_http_server::scope`](::aws_smithy_http_server::scope), this macro has knowledge
/// of the service and any operations _not_ specified will be placed in the opposing group.
///
/// # Example
///
/// ```rust
/// scope! {
///     /// Includes [`Operation`], excluding all other operations.
///     struct ScopeA {
///         includes: [Operation]
///     }
/// }
///
/// scope! {
///     /// Excludes [`Operation`], excluding all other operations.
///     struct ScopeB {
///         excludes: [Operation]
///     }
/// }
///
/// # use ::aws_smithy_http_server::plugin::{Plugin, Scoped};
/// # use simple::scope;
/// # struct MockPlugin;
/// # impl<S, Op, T> Plugin<S, Op, T> for MockPlugin { type Output = u32; fn apply(&self, input: T) -> u32 { 3 } }
/// # let scoped_a = Scoped::new::<ScopeA>(MockPlugin);
/// # let scoped_b = Scoped::new::<ScopeB>(MockPlugin);
/// # let a = Plugin::<(), simple::operation_shape::Operation, u64>::apply(&scoped_a, 6);
/// # let b = Plugin::<(), simple::operation_shape::Operation, u64>::apply(&scoped_b, 6);
/// # assert_eq!(a, 3_u32);
/// # assert_eq!(b, 6_u64);
/// ```
#[macro_export]
macro_rules! scope {
                // Completed, render impls
                (@ $ name: ident, $ contains: ident () ($($ temp: ident)*) ($($ not_member: ident)*)) => {
                    $(
                        impl ::aws_smithy_http_server::plugin::scoped::Membership<$ temp> for $ name {
                            type Contains = ::aws_smithy_http_server::plugin::scoped::$ contains;
                        }
                    )*
                    $(
                        impl ::aws_smithy_http_server::plugin::scoped::Membership<$ not_member> for $ name {
                            type Contains = ::aws_smithy_http_server::plugin::scoped::$ contains;
                        }
                    )*
                };
                // All `not_member`s exhausted, move `temp` into `not_member`
                (@ $ name: ident, $ contains: ident ($($ member: ident)*) ($($ temp: ident)*) ()) => {
                    scope! { @ $ name, $ contains ($($ member)*) () ($($ temp)*) }
                };

                // Operation match found, pop from both `member` and `not_member`
                (@ $ name: ident, $ contains: ident (Operation $($ member: ident)*) ($($ temp: ident)*) (Operation $($ not_member: ident)*)) => {
                    scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                };
                // Operation match not found, pop from `not_member` into `temp` stack
                (@ $ name: ident, $ contains: ident (Operation $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                    scope! { @ $ name, $ contains (Operation $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                };

                (
                    $(#[$ attrs:meta])*
                    $ vis:vis struct $ name:ident {
                        includes: [$($ include:ident),*]
                    }
                ) => {
                    use $ crate::operation_shape::*;
                    ::aws_smithy_http_server::scope! {
                        $(#[$ attrs])*
                        $ vis struct $ name {
                            includes: [$($ include),*],
                            excludes: []
                        }
                    }
                    scope! { @ $ name, False ($($ include)*) () (Operation) }
                };
                (
                    $(#[$ attrs:meta])*
                    $ vis:vis struct $ name:ident {
                        excludes: [$($ exclude:ident),*]
                    }
                ) => {
                    use $ crate::operation_shape::*;

                    ::aws_smithy_http_server::scope! {
                        $(#[$ attrs])*
                        $ vis struct $ name {
                            includes: [],
                            excludes: [$($ exclude),*]
                        }
                    }
                    scope! { @ $ name, True ($($ exclude)*) () (Operation) }
                };
            }
#[derive(::std::fmt::Debug)]
pub struct Config<L, H, M> {
    layers: L,
    http_plugins: H,
    model_plugins: M,
}

impl Config<(), (), ()> {
    pub fn builder() -> config::Builder<
        tower::layer::util::Identity,
        ::aws_smithy_http_server::plugin::IdentityPlugin,
        ::aws_smithy_http_server::plugin::IdentityPlugin,
    > {
        config::Builder {
            layers: tower::layer::util::Identity::new(),
            http_plugins: aws_smithy_http_server::plugin::IdentityPlugin,
            model_plugins: aws_smithy_http_server::plugin::IdentityPlugin,
        }
    }
}

/// Module hosting the builder for [`Config`].
pub mod config {
    use aws_smithy_http_server::plugin::{HttpMarker, ModelMarker, PluginStack};
    use tower::layer::util::Stack;

    #[derive(::std::fmt::Debug)]
    pub struct Builder<L, H, M> {
        pub(crate) layers: L,
        pub(crate) http_plugins: H,
        pub(crate) model_plugins: M,
    }

    impl<L, H, M> Builder<L, H, M> {
        pub fn layer<NewLayer>(self, layer: NewLayer) -> Builder<Stack<NewLayer, L>, H, M> {
            Builder {
                layers: Stack::new(layer, self.layers),
                http_plugins: self.http_plugins,
                model_plugins: self.model_plugins,
            }
        }

        // We eagerly require `NewPlugin: HttpMarker`, despite not really needing it, because compiler
        // errors get _substantially_ better if the user makes a mistake.
        pub fn http_plugin<NewPlugin: HttpMarker>(
            self,
            http_plugin: NewPlugin,
        ) -> Builder<L, PluginStack<NewPlugin, H>, M> {
            Builder {
                layers: self.layers,
                http_plugins: PluginStack::new(http_plugin, self.http_plugins),
                model_plugins: self.model_plugins,
            }
        }

        // We eagerly require `NewPlugin: ModelMarker`, despite not really needing it, because compiler
        // errors get _substantially_ better if the user makes a mistake.
        pub fn model_plugin<NewPlugin: ModelMarker>(
            self,
            model_plugin: NewPlugin,
        ) -> Builder<L, H, PluginStack<NewPlugin, M>> {
            Builder {
                layers: self.layers,
                http_plugins: self.http_plugins,
                model_plugins: PluginStack::new(model_plugin, self.model_plugins),
            }
        }

        pub fn build(self) -> super::Config<L, H, M> {
            super::Config {
                layers: self.layers,
                http_plugins: self.http_plugins,
                model_plugins: self.model_plugins,
            }
        }
    }
}
