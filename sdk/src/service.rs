use aws_smithy_http_server::plugin::IdentityPlugin;

// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// The service builder for [`SimpleService`].
///
/// Constructed via [`SimpleService::builder_with_plugins`] or [`SimpleService::builder_without_plugins`].
pub struct SimpleServiceBuilder<Body, Plugin> {
    operation: Option<aws_smithy_http_server::routing::Route<Body>>,
    config: Config<Plugin>,
}

impl<Body, Plugin> SimpleServiceBuilder<Body, Plugin> {
    /// Sets the [`Operation`](crate::operation_shape::Operation) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use simple::SimpleService;
    ///
    /// use simple::{input, output};
    ///
    /// async fn handler(input: input::OperationInput) -> output::OperationOutput {
    ///     todo!()
    /// }
    ///
    /// let app = SimpleService::builder_without_plugins()
    ///     .operation(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: SimpleService<aws_smithy_http_server::routing::Route<aws_smithy_http::body::SdkBody>> = app;
    /// ```
    ///
    pub fn operation<HandlerType, HandlerExtractors, ServiceExtractors>(
        self,
        handler: HandlerType,
    ) -> Self
    where
        HandlerType: aws_smithy_http_server::operation::Handler<
            crate::operation_shape::Operation,
            HandlerExtractors,
        >,
        aws_smithy_http_server::operation::Operation<
            aws_smithy_http_server::operation::IntoService<
                crate::operation_shape::Operation,
                HandlerType,
            >,
        >: aws_smithy_http_server::operation::Upgradable<
            aws_smithy_http_server::proto::rest_json_1::RestJson1,
            crate::operation_shape::Operation,
            ServiceExtractors,
            Body,
            Plugin,
        >,
    {
        use aws_smithy_http_server::operation::OperationShapeExt;
        self.operation_operation(crate::operation_shape::Operation::from_handler(handler))
    }

    /// Sets the [`Operation`](crate::operation_shape::Operation) operation.
    ///
    /// This should be an [`Operation`](aws_smithy_http_server::operation::Operation) created from
    /// [`Operation`](crate::operation_shape::Operation) using either
    /// [`OperationShape::from_handler`](aws_smithy_http_server::operation::OperationShapeExt::from_handler) or
    /// [`OperationShape::from_service`](aws_smithy_http_server::operation::OperationShapeExt::from_service).
    pub fn operation_operation<Operation, Extractors>(mut self, operation: Operation) -> Self
    where
        Operation: aws_smithy_http_server::operation::Upgradable<
            aws_smithy_http_server::proto::rest_json_1::RestJson1,
            crate::operation_shape::Operation,
            Extractors,
            Body,
            Plugin,
        >,
    {
        self.operation = Some(operation.upgrade(&self.config.plugin));
        self
    }
}

impl<Body, Plugin> SimpleServiceBuilder<Body, Plugin> {
    /// Constructs a [`SimpleService`] from the arguments provided to the builder.
    ///
    /// Forgetting to register a handler for one or more operations will result in an error.
    ///
    /// Check out [`SimpleServiceBuilder::build_unchecked`] if you'd prefer the service to return status code 500 when an
    /// unspecified route is requested.
    pub fn build(
        self,
    ) -> Result<SimpleService<aws_smithy_http_server::routing::Route<Body>>, MissingOperationsError>
    {
        let router = {
            use aws_smithy_http_server::operation::OperationShape;
            let mut missing_operation_names = std::collections::HashMap::new();
            if self.operation.is_none() {
                missing_operation_names
                    .insert(crate::operation_shape::Operation::NAME, ".operation()");
            }
            if !missing_operation_names.is_empty() {
                return Err(MissingOperationsError {
                    operation_names2setter_methods: missing_operation_names,
                });
            }
            let unexpected_error_msg = "this should never panic since we are supposed to check beforehand that a handler has been registered for this operation; please file a bug report under https://github.com/awslabs/smithy-rs/issues";

            aws_smithy_http_server::proto::rest::router::RestRouter::from_iter([(
                request_specs::operation(),
                self.operation.expect(unexpected_error_msg),
            )])
        };
        Ok(SimpleService {
            router: aws_smithy_http_server::routing::RoutingService::new(router),
        })
    }

    /// Constructs a [`SimpleService`] from the arguments provided to the builder.
    /// Operations without a handler default to returning 500 Internal Server Error to the caller.
    ///
    /// Check out [`SimpleServiceBuilder::build`] if you'd prefer the builder to fail if one or more operations do
    /// not have a registered handler.
    pub fn build_unchecked(self) -> SimpleService<aws_smithy_http_server::routing::Route<Body>>
    where
        Body: Send + 'static,
    {
        let router = aws_smithy_http_server::proto::rest::router::RestRouter::from_iter([(
                        request_specs::operation(),
                        self.operation.unwrap_or_else(|| {
                            aws_smithy_http_server::routing::Route::new(<aws_smithy_http_server::operation::FailOnMissingOperation as aws_smithy_http_server::operation::Upgradable<
                                aws_smithy_http_server::proto::rest_json_1::RestJson1,
                                crate::operation_shape::Operation,
                                (),
                                _,
                                _,
                            >>::upgrade(aws_smithy_http_server::operation::FailOnMissingOperation, &self.config.plugin))
                        })
                    ),]);
        SimpleService {
            router: aws_smithy_http_server::routing::RoutingService::new(router),
        }
    }
}

/// The error encountered when calling the [`SimpleServiceBuilder::build`] method if one or more operation handlers are not
/// specified.
#[derive(Debug)]
pub struct MissingOperationsError {
    operation_names2setter_methods: std::collections::HashMap<&'static str, &'static str>,
}

impl std::fmt::Display for MissingOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "You must specify a handler for all operations attached to `SimpleService`.\n\
                        We are missing handlers for the following operations:\n",
        )?;
        for operation_name in self.operation_names2setter_methods.keys() {
            writeln!(f, "- {}", operation_name)?;
        }

        writeln!(f, "\nUse the dedicated methods on `SimpleServiceBuilder` to register the missing handlers:")?;
        for setter_name in self.operation_names2setter_methods.values() {
            writeln!(f, "- {}", setter_name)?;
        }
        Ok(())
    }
}

impl std::error::Error for MissingOperationsError {}

mod request_specs {
    pub(super) fn operation() -> aws_smithy_http_server::routing::request_spec::RequestSpec {
        aws_smithy_http_server::routing::request_spec::RequestSpec::new(
            http::Method::POST,
            aws_smithy_http_server::routing::request_spec::UriSpec::new(
                aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                    aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(
                        vec![
                            aws_smithy_http_server::routing::request_spec::PathSegment::Literal(
                                String::from("operation"),
                            ),
                        ],
                    ),
                    aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(
                        vec![],
                    ),
                ),
            ),
        )
    }
}

#[allow(missing_docs)] // documentation missing in model
///
/// See the [root](crate) documentation for more information.
#[derive(Clone)]
pub struct SimpleService<S = aws_smithy_http_server::routing::Route> {
    router: aws_smithy_http_server::routing::RoutingService<
        aws_smithy_http_server::proto::rest::router::RestRouter<S>,
        aws_smithy_http_server::proto::rest_json_1::RestJson1,
    >,
}

impl SimpleService<()> {
    pub fn builder<Body, Plugin>(config: Config<Plugin>) -> SimpleServiceBuilder<Body, Plugin> {
        SimpleServiceBuilder {
            operation: None,
            config,
        }
    }
}

impl<S> SimpleService<S> {
    /// Converts [`SimpleService`] into a [`MakeService`](tower::make::MakeService).
    pub fn into_make_service(self) -> aws_smithy_http_server::routing::IntoMakeService<Self> {
        aws_smithy_http_server::routing::IntoMakeService::new(self)
    }

    /// Converts [`SimpleService`] into a [`MakeService`](tower::make::MakeService) with [`ConnectInfo`](aws_smithy_http_server::request::connect_info::ConnectInfo).
    pub fn into_make_service_with_connect_info<C>(
        self,
    ) -> aws_smithy_http_server::routing::IntoMakeServiceWithConnectInfo<Self, C> {
        aws_smithy_http_server::routing::IntoMakeServiceWithConnectInfo::new(self)
    }

    /// Applies a [`Layer`](tower::Layer) uniformly to all routes.
    pub fn layer<L>(self, layer: &L) -> SimpleService<L::Service>
    where
        L: tower::Layer<S>,
    {
        SimpleService {
            router: self.router.map(|s| s.layer(layer)),
        }
    }

    /// Applies [`Route::new`](aws_smithy_http_server::routing::Route::new) to all routes.
    ///
    /// This has the effect of erasing all types accumulated via [`layer`](SimpleService::layer).
    pub fn boxed<B>(self) -> SimpleService<aws_smithy_http_server::routing::Route<B>>
    where
        S: tower::Service<
            http::Request<B>,
            Response = http::Response<aws_smithy_http_server::body::BoxBody>,
            Error = std::convert::Infallible,
        >,
        S: Clone + Send + 'static,
        S::Future: Send + 'static,
    {
        self.layer(&tower::layer::layer_fn(
            aws_smithy_http_server::routing::Route::new,
        ))
    }
}

impl<B, RespB, S> tower::Service<http::Request<B>> for SimpleService<S>
where
    S: tower::Service<http::Request<B>, Response = http::Response<RespB>> + Clone,
    RespB: http_body::Body<Data = bytes::Bytes> + Send + 'static,
    RespB::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
{
    type Response = http::Response<aws_smithy_http_server::body::BoxBody>;
    type Error = S::Error;
    type Future = aws_smithy_http_server::routing::RoutingFuture<S, B>;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.router.poll_ready(cx)
    }

    fn call(&mut self, request: http::Request<B>) -> Self::Future {
        self.router.call(request)
    }
}

pub struct Config<Plugin> {
    // Built final plugin
    pub(crate) plugin: Plugin,
}

impl Config<()> {
    pub fn builder() -> config::Builder<IdentityPlugin> {
        config::Builder {
            plugin_pipeline: aws_smithy_http_server::plugin::PluginPipeline::default(),
            aws_auth_authenticate_inserted_at: None,
            aws_auth_authorize_inserted_at: None,
            plugin_count: 0,
        }
    }
}

/// Module hosting the builder for `Config`.
pub mod config {
    use aws_smithy_http_server::plugin::{IdentityPlugin, PluginPipeline, PluginStack};

    // This follows the same pattern as `MissingOperationsError`.
    #[derive(Debug)]
    pub struct Error {
        msg: String,
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            writeln!(f, "{}", self.msg)?;
            Ok(())
        }
    }

    impl std::error::Error for Error {}

    pub struct Builder<Plugin> {
        pub(super) plugin_pipeline: PluginPipeline<Plugin>,

        // There's one `usize` per thing that must be configured, tracking
        // the index of when the plugin was inserted.
        pub(super) aws_auth_authenticate_inserted_at: Option<usize>,
        pub(super) aws_auth_authorize_inserted_at: Option<usize>,

        pub(super) plugin_count: usize,
    }

    impl<Plugin> Builder<Plugin> {
        /// Apply a new plugin after the ones that have already been registered.
        pub fn plugin<NewPlugin>(
            self,
            plugin: NewPlugin,
        ) -> Builder<PluginStack<NewPlugin, Plugin>> {
            Builder {
                plugin_pipeline: self.plugin_pipeline.push(plugin),
                aws_auth_authenticate_inserted_at: self.aws_auth_authenticate_inserted_at,
                aws_auth_authorize_inserted_at: self.aws_auth_authorize_inserted_at,
                plugin_count: self.plugin_count + 1,
            }
        }

        // TODO: The types are obviously wrong but we can't depend on things here, so we just apply
        // the `IdentityPlugin`.
        // If building the plugin is fallible, this would return a `Result`.
        pub fn aws_auth_authenticate(
            self,
            _authenticator: String,
        ) -> Builder<PluginStack<IdentityPlugin, Plugin>> {
            Builder {
                plugin_pipeline: self.plugin_pipeline.push(IdentityPlugin),
                aws_auth_authenticate_inserted_at: Some(self.plugin_count),
                aws_auth_authorize_inserted_at: self.aws_auth_authorize_inserted_at,
                plugin_count: self.plugin_count + 1,
            }
        }

        pub fn aws_auth_authorize(
            self,
            _authorizer: String,
        ) -> Builder<PluginStack<IdentityPlugin, Plugin>> {
            Builder {
                plugin_pipeline: self.plugin_pipeline.push(IdentityPlugin),
                aws_auth_authenticate_inserted_at: self.aws_auth_authenticate_inserted_at,
                aws_auth_authorize_inserted_at: Some(self.plugin_count),
                plugin_count: self.plugin_count + 1,
            }
        }

        /// Build the service configuration.
        ///
        // This would be infallible if there's nothing in the Smithy model that requires
        // configuration at runtime.
        pub fn build(self) -> Result<super::Config<PluginPipeline<Plugin>>, Error> {
            let mut config_name_to_setter_methods = std::collections::HashMap::new();
            if self.aws_auth_authenticate_inserted_at.is_none() {
                config_name_to_setter_methods.insert(
                    "AWS Auth authenticate is not configured",
                    "aws_auth_authenticate",
                );
            }

            // Authz is not mandatory!
            // if self.aws_auth_authorize_inserted_at.is_none() {
            //     config_name_to_setter_methods
            //         .insert("AWS Auth authorize is not configured", "aws_auth_authorize");
            // }

            if !config_name_to_setter_methods.is_empty() {
                let mut msg = "You must configure the following for `SimpleService`.".to_owned();
                for config_name in config_name_to_setter_methods.keys() {
                    msg += &format!("\n- {}", config_name);
                }
                msg += "\nUse the dedicated methods on `Config` to configure things:";
                for setter_name in config_name_to_setter_methods.values() {
                    msg += &format!("\n- `{}`", setter_name);
                }

                return Err(Error { msg });
            }

            let panic_msg = "this should never panic since we are supposed to check beforehand that all required things have been configured; please file a bug report under https://github.com/awslabs/smithy-rs/issues";

            let aws_auth_authenticate_inserted_at =
                self.aws_auth_authenticate_inserted_at.expect(panic_msg);
            let aws_auth_authorize_inserted_at =
                self.aws_auth_authenticate_inserted_at.expect(panic_msg);
            let mut msg = String::new(); // Doesn't allocate.

            if aws_auth_authorize_inserted_at <= aws_auth_authenticate_inserted_at {
                msg += "Authentication must be configured before authorization. Call `aws_auth_authenticate` before `aws_auth_authorize`."
            }

            if !msg.is_empty() {
                return Err(Error { msg });
            }

            Ok(super::Config {
                plugin: self.plugin_pipeline,
            })
        }
    }
}
